# Integrating with C++（与 C++ 集成）

## The C++

In order to demonstrate the connection between C++ and QML in Qt for MCUs, we will create a simple ``Counter`` singleton holding an integer value. Notice that we start from a ``struct`` and not a ``class``. This is common practice in Qt Quick Ultralite. 

为了演示 Qt for MCUs 中 C++ 和 QML 之间的连接，我们将创建一个简单的 ``Counter`` 单例，其中包含一个整数值。请注意，我们从 ``struct`` 而不是 ``class`` 开始。这是 Qt Quick Ultralite 中常见的做法。

The singleton will be used from a small UI as shown below.

单例将如下所示的小 UI 中使用。

![](./assets/counter.png)

The ``Counter`` struct provides a property, ``value``, as well as methods for changing the value, ``increase`` and ``decrease``, as well as a ``reset`` method. It also provides a signal, ``hasBeenReset``.

``Counter`` 结构体提供了一个属性，``value``，以及用于更改值的 ``increase`` 和 ``decrease`` 方法，以及一个 ``reset`` 方法。它还提供了一个信号，``hasBeenReset``。


<<< @/docs/ch20-qtformcu/src/cppintegration/counter.h#global

Coming from Qt, this looks odd. This is where Qt for MCUs shows the main differences. There is no ``QObject`` base class or ``Q_OBJECT`` macro, instead a new set of classes from the ``Qul`` is used. In this particular case, the base class is the ``Qul::Singleton`` class, creating a globally accessible singleton in the QML world. We also use the ``Qul::Signal`` class to create a signal and the ``Qul::Property`` class to create a property. All public, non-overloaded member functions are exposed to QML automatically.

来自 Qt 的，这看起来很奇怪。这就是 Qt for MCUs 显示的主要区别。没有 ``QObject`` 基类或 ``Q_OBJECT`` 宏，而是使用 ``Qul`` 的一组新类。在这个特定的情况下，基类是 ``Qul::Singleton`` 类，在 QML 世界中创建一个全局可访问的单例。我们还使用 ``Qul::Signal`` 类来创建信号，使用 ``Qul::Property`` 类来创建属性。所有公共、非重载成员函数都会自动暴露给 QML。

::: tip
To create an element that can be instantiated from QML, instead of a singleton, use the ``Qul::Object`` base class.

要创建可以从 QML 实例化的元素，而不是单例，请使用 ``Qul::Object`` 基类。
:::

The struct is then exposed to QML using the CMake macro ``qul_target_generate_interfaces``. Below you can see the ``CMakeLists.txt``, based on the file generated by Qt Creator, with the ``counter.h`` and ``counter.cpp`` files added.

然后使用 CMake 宏 ``qul_target_generate_interfaces`` 将结构体暴露给 QML。在下面的示例中，你可以看到基于 Qt Creator 生成的 ``CMakeLists.txt``，其中添加了 ``counter.h`` 和 ``counter.cpp`` 文件。

<<< @/docs/ch20-qtformcu/src/cppintegration/CMakeLists.txt#generate_interfaces

Now, let's continue with the implementation of the ``Counter`` struct. First up, for the ``value`` property, we use the ``value`` and ``setValue`` functions to access and modify the actual value. In our case, the property holds and ``int``, but just as for the ordinary QML engine, types are [mapped between C++ and QML](https://doc.qt.io/QtForMCUs/qtul-integratecppqml.html#type-mapping).

接下来，让我们继续实现 ``Counter`` 结构体。首先，对于 ``value`` 属性，我们使用 ``value`` 和 ``setValue`` 函数来访问和修改实际值。在我们的例子中，属性包含一个 ``int``，但就像普通 QML 引擎一样，类型在 C++ 和 QML 之间 [进行了映射](https://doc.qt.io/QtForMCUs/qtul-integratecppqml.html#type-mapping)。

This is used in the constructor, shown below, that sets the initial value to zero.

这在我们下面的构造函数中使用，该构造函数将初始值设置为零。

<<< @/docs/ch20-qtformcu/src/cppintegration/counter.cpp#ctor

The ``increase`` and ``decrease`` functions look similar. They use the getter and setter instead of interacting directly with the value.

``increase`` 和 ``decrease`` 函数看起来很相似。它们使用 getter 和 setter，而不是直接与值交互。


<<< @/docs/ch20-qtformcu/src/cppintegration/counter.cpp#incdec

``Counter`` also has a signal. The signal is represented by the ``Qul::Signal`` instance named ``hasReset``. The signal takes a function signature as template argument, so to create a signal carrying an integer, create a ``Qul::Signal<void(int)>``. In this case, the signal does not carry any values, so it is defined as a `void(void)`. To emit the signal, we simply call it as if it was an ordinary function as shown in the ``reset`` function below.

``Counter`` 还有一个信号。信号由名为 ``hasReset`` 的 ``Qul::Signal`` 实例表示。信号将函数签名作为模板参数，因此要创建一个携带整数的信号，请创建一个 ``Qul::Signal<void(int)>``。在这种情况下，信号不携带任何值，因此定义为 `void(void)`。要发出信号，我们只需像普通函数一样调用它，如下面的 ``reset`` 函数所示。


<<< @/docs/ch20-qtformcu/src/cppintegration/counter.cpp#reset

## The QML

The QML code produces the simple user interface shown below.

QML 代码生成如下所示的简单用户界面。

![](./assets/counter.png)

We will look at the UI in three parts. First, the basic structure, and bindings to ``Counter.value``:

我们将从 UI 的三个部分开始。首先，基本结构，以及与 ``Counter.value`` 的绑定：


```
import QtQuick

Rectangle {
    width: 480
    height: 272

    Column {
        // Left buttons goes here
    }

    Column {
        // Right buttons goes here
    }

    Text {
        anchors.centerIn: parent
        text: Counter.value;
    }
}
```

As you can tell, the ``Text`` element's ``text`` property is bound to the ``Counter.value`` as in all QML.

如你所见，``Text`` 元素的 ``text`` 属性绑定到 ``Counter.value``，就像在所有 QML 中一样。

Now, let's look at the left side buttons. These are used to invoke the C++ methods provided via the ``Counter`` singleton. The ``PlainButton`` is a QML element that we use to create these simple buttons. It lets you set the text, background color and a handler for the ``clicked`` signal. As you can tell, each button calls the corresponding method on the ``Counter`` singleton.

现在，让我们看看左侧按钮。这些按钮用于通过 ``Counter`` 单例调用 C++ 提供的方法。``PlainButton`` 是一个 QML 元素，我们用它来创建这些简单的按钮。它让你设置文本、背景颜色和 ``clicked`` 信号的处理器。如你所见，每个按钮都会在 ``Counter`` 单例上调用相应的方法。


<<< @/docs/ch20-qtformcu/src/cppintegration/cppintegration.qml#left

The buttons on the right modify the ``Counter.value`` directly from QML. This is possible to do, but invisible to C++. There is no simple way for C++ to monitor if a property has changed, so if a C++ reaction is needed, it is recommended to use a setter method, rather than directly modifying the property value.

右侧的按钮直接从 QML 修改 ``Counter.value``。这是可能的，但对 C++ 来说是不可见的。没有简单的方法可以让 C++ 监控一个属性是否已更改，因此如果需要 C++ 反应，建议使用 setter 方法，而不是直接修改属性值。

<<< @/docs/ch20-qtformcu/src/cppintegration/cppintegration.qml#right

This shows how to provide a singleton from C++ and how to make function calls, emit signals, and share state (properties) between C++ and QML.

这显示了如何从 C++ 提供单例，以及如何进行函数调用、发出信号以及共享 C++ 和 QML 之间的状态（属性）。

## Revisiting the CMake file

The ``CMakeLists.txt`` file may look familiar to you, but there are some tips and tricks that we need to discuss.

``CMakeLists.txt`` 文件对你来说可能很熟悉，但我们需要讨论一些技巧和窍门。

First of all, in order to expose a C++ class to QML, use the ``qul_target_generate_interfaces``, e.g:

首先，为了将 C++ 类暴露给 QML，请使用 ``qul_target_generate_interfaces``，例如：

```
qul_target_generate_interfaces(cppintegration counter.h)
```

The other half, the QML files, are added using the ``qul_target_qml_sources`` macro. If you have multiple QML files, simply list them one by one as shown below:

另一部分，QML 文件，使用 ``qul_target_qml_sources`` 宏添加。如果你有多个 QML 文件，只需按如下所示一个接一个地列出它们：

```
qul_target_qml_sources(cppintegration cppintegration.qml PlainButton.qml)
```

Another interesting aspect is that we are building a C++ project without writing a ``main`` function. This is taken care of by the ``app_target_default_main`` macro that adds a reference main implementation to the project. You can of course replace this with a custom ``main`` function if you need more control.

另一个有趣方面是，我们正在构建一个没有编写 ``main`` 函数的 C++ 项目。这是由 ``app_target_default_main`` 宏处理的，该宏向项目添加了一个参考主实现。当然，如果你需要更多的控制，你可以用自定义的 ``main`` 函数替换它。

```
app_target_default_main(cppintegration cppintegration)
```

Finally, the libraries linked to are not the standard Qt ones, but the ``Qul::`` ones, e.g:

最后，链接的库不是标准的 Qt 库，而是 ``Qul::``，例如：


```
target_link_libraries(cppintegration
    Qul::QuickUltralite
    Qul::QuickUltralitePlatform)
```

        
::: tip Links
Further reading at qt.io:
* [Integrate C++ and QML](https://doc.qt.io/QtForMCUs/qtul-integratecppqml.html)

这是[Qt for MCUs](https://doc.qt.io/QtForMCUs/) 中的进一步阅读：
:::
