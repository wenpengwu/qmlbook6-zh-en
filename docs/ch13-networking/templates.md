# Templates（模板）

When working with HTML projects they often use template driven development. A small HTML stub is expanded on the server side with code generated by the server using a template mechanism. For example, for a photo list, the list header would be coded in HTML and the dynamic image list would be dynamically generated using a template mechanism. In general, this can also be done using QML but there are some issues with it.

在处理HTML项目时，他们通常使用模板驱动的开发。在服务器端用服务器使用模板机制生成的代码扩展一个小的HTML存根。例如，对于照片列表，列表标题将用HTML编码，动态图像列表将使用模板机制动态生成。一般来说，这也可以使用QML完成，但它存在一些问题。

First, it is not necessary. The reason HTML developers are doing this is to overcome limitations on the HTML backend. There is no component model yet in HTML so dynamic aspects have to be covered using these mechanisms or using programmatically javascript on the client side. Many JS frameworks are out there (jQuery, dojo, backbone, angular, …) to solve this issue and put more logic into the client-side browser to connect with a network service. The client would then just use a web-service API (e.g. serving JSON or XML data) to communicate with the server. This seems also the better approach for QML.

首先，这是不必要的。HTML开发人员这样做的原因是为了克服HTML后端的限制。还没有组件模型，所以动态方面必须使用这些机制或使用客户端浏览器上的javascript编程来解决。有许多JS框架（jQuery、dojo、backbone、angular、...）来解决这个问题，并将更多逻辑放入客户端浏览器以连接到网络服务。然后客户端只需使用web服务API（例如，提供JSON或XML数据）与服务器通信。这似乎是更好的方法。

The second issue is the component cache from QML. When QML accesses a component it caches the render-tree and just loads the cached version for rendering. A modified version on disk or remote would not be detected without restarting the client. To overcome this issue we could use a trick. We could use URL fragments to load the URL (e.g. [http://localhost:8080/main.qml#1234](http://localhost:8080/main.qml#1234)), where ‘#1234’ is the fragment. The HTTP server serves always the same document but QML would store this document using the full URL, including the fragment. Every time we would access this URL the fragment would need to change and the QML cache would not get a positive hit. A fragment could be for example the current time in milliseconds or a random number.


第二个问题是来自QML的组件缓存。当QML访问组件时，它会缓存渲染树，只加载缓存的版本进行渲染。如果不重新启动客户端，将无法检测到磁盘或远程上的修改版本。为了克服这个问题，我们可以使用一个技巧。我们可以使用URL片段来加载URL（例如[http://localhost:8080/main.qml#1234])，其中“#1234”是片段。HTTP服务器始终提供相同的文档，但QML将使用完整的URL（包括片段）存储该文档。每次我们访问这个URL时，片段都需要更改，QML缓存不会得到正面的点击。例如，片段可以是以毫秒为单位的当前时间或随机数

```qml
Loader {
    source: 'http://localhost:8080/main.qml#' + new Date().getTime()
}
```

In summary templating is possible but not really recommended and does not play to the strength of QML. A better approach is to use web-services which serve JSON or XML data.

总结来说，模板是可能的，但并不真正推荐，并不适合QML的优势。更好的方法是使用web服务，它们提供JSON或XML数据。

