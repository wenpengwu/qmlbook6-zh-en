# Building an Application（构建应用程序）

In this chapter we will look at how you can combine Python and QML. The most natural way to combine the two worlds is to do as with C++ and QML, i.e. implement the logic in Python and the presentation in QML.

在本章中，我们将探讨如何将 Python 和 QML 结合起来。将两个世界结合的最自然方式是像 C++ 和 QML 那样，即用 Python 实现逻辑，用 QML 实现表示。

To do this, we need to understand how to combine QML and Python into a single program, and then how to implement interfaces between the two worlds. In the sub-sections below, we will look at how this is done. We will start simple and progress to an example exposing the capabilities of a Python module to QML through a Qt item model.

为了做到这一点，我们需要了解如何将 QML 和 Python 结合成一个程序，然后如何在这两个世界之间实现接口。在下面的子部分中，我们将探讨如何做到这一点。我们将从简单的例子开始，然后到一个通过 Qt 项目模型将 Python 模块的功能暴露给 QML 的例子。



## Running QML from Python（从 Python 运行 QML）

The very first step is to create a Python program that can host the *Hello World* QML program shown below.

第一步是创建一个 Python 程序，可以托管下面的 *Hello World* QML 程序。



<<< @/docs/ch19-python/src/basic/main.qml#global

To do this, we need a Qt mainloop provided by `QGuiApplication` from the `QtGui` module. We also need a `QQmlApplicationEngine` from the `QtQml` module. In order to pass the reference to the source file to the QML application engine, we also need the `QUrl` class from the `QtCore` module.

为了做到这一点，我们需要 `QtGui` 模块中的 `QGuiApplication` 提供的 Qt 主循环。我们还需要 `QtQml` 模块中的 `QQmlApplicationEngine`。为了将源文件的引用传递给 QML 应用程序引擎，我们还需要 `QtCore` 模块中的 `QUrl` 类。



In the code below we emulate the functionality of the boilerplate C++ code generated by Qt Creator for QML projects. It instantiates the application object, and creates a QML application engine. It then loads the QML and then ensures that the QML was loaded by checking if a root object was created. Finally, it exits and returns the value returned by the `exec` method of the application object.

在下面的代码中，我们模拟了 Qt Creator 为 QML 项目生成的样板 C++ 代码的功能。它实例化应用程序对象，并创建一个 QML 应用程序引擎。然后加载 QML，然后通过检查是否创建了根对象来检查 QML 是否被加载。最后，它退出并返回应用程序对象 `exec` 方法的值。




<<< @/docs/ch19-python/src/basic/basic.py#global

Executing the example results in a window with the title *Hello Python World*.

执行示例将导致一个标题为 *Hello Python World* 的窗口。


![](./assets/qml-hello-world.png)

::: tip
The example assumes that it is executed from the directory containing the `main.qml` source file. You can determine the location of the Python file being executed using the `__file__` variable. This can be used to locate the QML files relative to the Python file as shown in this [blog post](http://blog.qt.io/blog/2018/05/14/qml-qt-python/).

示例假设它是从包含 `main.qml` 源文件的目录中执行的。您可以使用 `__file__` 变量来确定正在执行的 Python 文件的路径。这可以用来相对于 Python 文件定位 QML 文件，如本[博客文章](http://blog.qt.io/blog/2018/05/14/qml-qt-python/)所示。
:::

## Exposing Python Objects to QML（将 Python 对象暴露给 QML）

The easiest way to share information between Python and QML is to expose a Python object to QML. This is done by registering a *context property* through the `QQmlApplicationEngine`. Before we can do that, we need to define a class so that we have an object to expose.

在 Python 和 QML 之间共享信息的最简单方法是向 QML 暴露一个 Python 对象。这是通过 `QQmlApplicationEngine` 注册一个 *上下文属性* 来完成的。在我们这样做之前，我们需要定义一个类，以便有一个要暴露的对象。


Qt classes come with a number of features that we want to be able to use. These are: signals, slots and properties. In this first example, we will restrict ourselves to a basic pair of signal and slot. The rest will be covered in the examples further on.

Qt 类附带了许多我们希望能够使用的功能。这些是：信号、插槽和属性。在这个第一个例子中，我们将自己限制在基本的信号和插槽对。其余的将在后面的例子中介绍。


### Signals and Slots（信号和槽）

We start with the class `NumberGenerator`. It has a constructor, a method called `updateNumber` and a signal called `nextNumber`. The idea is that when you call `updateNumber`, the signal `nextNumber` is emitted with a new random number. You can see the code for the class below, but first we will look at the details.

我们从 `NumberGenerator` 类开始。它有一个构造函数，一个名为 `updateNumber` 的方法和一个名为 `nextNumber` 的信号。想法是，当你调用 `updateNumber` 时，信号 `nextNumber` 会发出一个新随机数。您可以在下面看到类的代码，但首先我们将查看细节。


First of all we make sure to call `QObject.__init__` from our constructor. This is very important, as the example will not work without it.

首先，我们确保从我们的构造函数中调用 `QObject.__init__`。这是非常重要的，如果没有它，示例将无法工作。



Then we declare a signal by creating an instance of the `Signal` class from the `PySide6.QtCore` module. In this case, the signal carries an integer value, hence the `int`. The signal parameter name, `number`, is defined in the `arguments` parameter.

然后，我们通过从 `PySide6.QtCore` 模块创建 `Signal` 类的实例来声明一个信号。在这种情况下，信号携带一个整数值，因此是 `int`。信号参数名称 `number` 在 `arguments` 参数中定义。

Finally, we *decorate* the `updateNumber` method with the `@Slot()` decorator, thus turning it into a slot. There is no concept of *invokables* in Qt for Python, so all callable methods must be slots.

最后，我们使用 `@Slot()` 装饰器 *装饰* `updateNumber` 方法，从而将其转换为插槽。对于 Python 来说，Qt 中没有 *可调用* 的概念，因此所有可调用的方法都必须是插槽。

In the `updateNumber` method we emit the `nextNumber` signal using the `emit` method. This is a bit different than the syntax for doing so from QML or C++ as the signal is represented by an object instead of being a callable function.

在 `updateNumber` 方法中，我们使用 `emit` 方法发出 `nextNumber` 信号。这与从 QML 或 C++ 进行操作的语法略有不同，因为信号被表示为一个对象，而不是可调用的函数。


<<< @/docs/ch19-python/src/class-context-property/class.py#number-generator

Next up is to combine the class we just created with the boilerplate code for combining QML and Python from earlier. This gives us the following entry-point code.

接下来是将我们刚刚创建的类与前面 QML 和 Python 组合的样板代码结合起来。这给了我们以下入口点代码。


The interesting lines are the one where we first instantiate a `NumberGenerator`. This object is then exposed to QML using the `setContextProperty` method of the `rootContext` of the QML engine. This exposes the object to QML as a global variable under the name `numberGenerator`.

有趣的一行是我们首先实例化一个 `NumberGenerator`。然后使用 QML 引擎的 `rootContext` 的 `setContextProperty` 方法将该对象暴露给 QML。该对象在 QML 中作为名为 `numberGenerator` 的全局变量暴露出来。

<<< @/docs/ch19-python/src/class-context-property/class.py#main

Continuing to the QML code, we can see that we’ve created a Qt Quick Controls 2 user interface consisting of a `Button` and a `Label`. In the button’s `onClicked` handler, the `numberGenerator.updateNumber()` function is called. This is the slot of the object instantiated on the Python side.

继续 QML 代码，我们可以看到我们创建了一个由 `Button` 和 `Label` 组成的 Qt Quick Controls 2 用户界面。在按钮的 `onClicked` 处理程序中，调用了 `numberGenerator.updateNumber()` 函数。这是在 Python 端实例化的对象的插槽。

To receive a signal from an object that has been instantiated outside of QML we need to use a `Connections` element. This allows us to attach a signal handler to an existing target.

要从实例化在 QML 之外的某个对象接收信号，我们需要使用 `Connections` 元素。这允许我们将信号处理程序附加到现有目标上。


<<< @/docs/ch19-python/src/class-context-property/main.qml#global

### Properties（属性）

Instead of relying solely on signals and slots, the common way to expose state to QML is through properties. A property is a combination of a setter, getter and notification signal. The setter is optional, as we can also have read-only properties.

除了仅依赖信号和插槽之外，将状态暴露给 QML 的常见方式是通过属性。属性是设置器、获取器和通知信号的组合。设置器是可选的，因为我们也可能有只读属性。

To try this out we will update the `NumberGenerator` from the last example to a property based version. It will have two properties: `number`, a read-only property holding the last random number, and `maxNumber`, a read-write property holding the maximum value that can be returned. It will also have a slot, `updateNumber` that updates the random number.

要尝试这一点，我们将从上一个示例中更新 `NumberGenerator` 为基于属性的版本。它将有两个属性：`number`，一个只读属性，保存最后随机数，以及 `maxNumber`，一个可读写的属性，保存可以返回的最大值。它还有一个插槽 `updateNumber`，用于更新随机数。

Before we dive into the details of properties, we create a basic Python class for this. It consists of the relevant getters and setters, but not Qt signalling. As a matter of fact, the only Qt part here is the inheritance from `QObject`. Even the names of the methods are Python style, i.e. using underscores instead of camelCase.

在深入属性细节之前，我们为这个示例创建了一个基本的 Python 类。它由相关的获取器和设置器组成，但没有 Qt 信号。实际上，这里唯一的 Qt 部分是从 `QObject` 的继承。即使方法的名称也是 Python 风格，即使用下划线而不是驼峰式命名。

Take notice of the underscores (“`__`”) at the beginning of the `__set_number` method. This implies that it is a private method. So even when the `number` property is read-only, we provide a setter. We just don’t make it public. This allows us to take actions when changing the value (e.g. emitting the notification signal).

注意 `__set_number` 方法开头的下划线（“`__`”）。这意味着它是一个私有方法。因此，即使 `number` 属性是只读的，我们也提供了一个设置器。我们只是不公开它。这允许我们在更改值时采取行动（例如发出通知信号）。



```py
class NumberGenerator(QObject):
    def __init__(self):
        QObject.__init__(self)
        self.__number = 42
        self.__max_number = 99
    
    def set_max_number(self, val):
        if val < 0:
            val = 0
        
        if self.__max_number != val:
            self.__max_number = val
            
        if self.__number > self.__max_number:
            self.__set_number(self.__max_number)
    
    def get_max_number(self):
        return self.__max_number

    def __set_number(self, val):
        if self.__number != val:
            self.__number = val
    
    def get_number(self):
        return self.__number
```

In order to define properties, we need to import the concepts of `Signal`, `Slot`, and `Property` from `PySide2.QtCore`. In the full example, there are more imports, but these are the ones relevant to the properties.

为了定义属性，我们需要从 `PySide2.QtCore` 中导入 `Signal`、`Slot` 和 `Property` 的概念。在完整的示例中，有更多的导入，但与属性相关的只有这些。


```py
from PySide6.QtCore import QObject, Signal, Slot, Property
```

Now we are ready to define the first property, `number`. We start off by declaring the signal `numberChanged`, which we then invoke in the `__set_number` method so that the signal is emitted when the value is changed.

现在我们准备好定义第一个属性 `number` 了。我们首先声明信号 `numberChanged`，然后在 `__set_number` 方法中调用它，以便在值更改时发出信号。

After that, all that is left is to instantiate the `Property` object. The `Property` constructor takes three arguments in this case: the type (`int`), the getter (`get_number`) and the notification signal which is passed as a named argument (`notify=numberChanged`). Notice that the getter has a Python name, i.e. using underscore rather than camelCase, as it is used to read the value from Python. For QML, the property name, `number`, is used.

之后，剩下的就是实例化 `Property` 对象。在这种情况下，`Property` 构造函数接受三个参数：类型（`int`）、获取器（`get_number`）和通知信号，作为命名参数传递（`notify=numberChanged`）。请注意，获取器有一个 Python 名称，即使用下划线而不是驼峰式命名，因为它用于从 Python 读取值。对于 QML，属性名称 `number` 被使用。


```py
class NumberGenerator(QObject):

    # ...
    
    # number
    
    numberChanged = Signal(int)
    
    def __set_number(self, val):
        if self.__number != val:
            self.__number = val
            self.numberChanged.emit(self.__number)
    
    def get_number(self):
        return self.__number
    
    number = Property(int, get_number, notify=numberChanged)
```

This leads us to the next property, `maxNumber`. This is a read-write property, so we need to provide a setter, as well as everything that we did for the `number` property.

这使我们进入了下一个属性 `maxNumber`。这是一个读写属性，所以我们需要提供一个设置器，以及我们为 `number` 属性所做的一切。

First up we declare the `maxNumberChanged` signal. This time, using the `@Signal` decorator instead of instantiating a `Signal` object. We also provide a setter slot, `setMaxNumber` with a Qt name (camelCase) that simply calls the Python method `set_max_number` alongside a getter with a Python name. Again, the setter emits the change signal when the value is updated.

首先，我们声明 `maxNumberChanged` 信号。这次，使用 `@Signal` 装饰器而不是实例化一个 `Signal` 对象。我们还提供了一个设置器槽 `setMaxNumber`，它使用 Qt 名称（驼峰式命名）简单地调用 Python 方法 `set_max_number`，以及一个使用 Python 名称的获取器。同样，当值更新时，设置器会发出更改信号。

Finally we put the pieces together into a read-write property by instantiating a `Property` object taking the type, getter, setter and notification signal as arguments.

最后，我们将这些部分组合成一个读写属性，通过实例化一个 `Property` 对象，将类型、获取器、设置器和通知信号作为参数传递。

```py
class NumberGenerator(QObject):

    # ...

    # maxNumber

    @Signal
    def maxNumberChanged(self):
        pass

    @Slot(int)
    def setMaxNumber(self, val):
        self.set_max_number(val)

    def set_max_number(self, val):
        if val < 0:
            val = 0
        
        if self.__max_number != val:
            self.__max_number = val
            self.maxNumberChanged.emit()
            
        if self.__number > self.__max_number:
            self.__set_number(self.__max_number)
    
    def get_max_number(self):
        return self.__max_number

    maxNumber = Property(int, get_max_number, set_max_number, notify=maxNumberChanged)
```

Now we have properties for the current random number, `number`, and the maximum random number, `maxNumber`. All that is left is a slot to produce a new random number. It is called `updateNumber` and simply sets a new random number.

现在我们有了当前随机数 `number` 和最大随机数 `maxNumber` 的属性。剩下的就是生成一个新随机数的槽。它被调用为 `updateNumber`，只需设置一个新的随机数即可。

```py
class NumberGenerator(QObject):

    # ...
    
    @Slot()
    def updateNumber(self):
        self.__set_number(random.randint(0, self.__max_number))
```

Finally, the number generator is exposed to QML through a root context property.

最后，数字生成器通过根上下文属性暴露给 QML。

<<< @/docs/ch19-python/src/property/property.py#main

In QML, we can bind to the `number` as well as the `maxNumber` properties of the `numberGenerator` object. In the `onClicked` handler of the `Button` we call the `updateNumber` method to generate a new random number and in the `onValueChanged` handler of the `Slider` we set the `maxNumber` property using the `setMaxNumber` method. This is because altering the property directly through Javascript would destroy the bindings to the property. By using the setter method explicitly, this is avoided.

在 QML 中，我们可以绑定到 `numberGenerator` 对象的 `number` 以及 `maxNumber` 属性。在 `Button` 的 `onClicked` 处理程序中，我们调用 `updateNumber` 方法生成一个新的随机数，在 `Slider` 的 `onValueChanged` 处理程序中，我们使用 `setMaxNumber` 方法设置 `maxNumber` 属性。这是因为通过 Javascript 直接更改属性会破坏属性与绑定的关系。通过显式使用设置器方法，可以避免这种情况。


<<< @/docs/ch19-python/src/property/main.qml#global

## Exposing a Python class to QML（将 Python 类暴露给 QML）

Up until now, we’ve instantiated an object Python and used the `setContextProperty` method of the `rootContext` to make it available to QML. Being able to instantiate the object from QML allows better control over object life-cycles from QML. To enable this, we need to expose the *class*, instead of the *object*, to QML.

到目前为止，我们实例化了一个 Python 对象，并使用 `rootContext` 的 `setContextProperty` 方法使其可用于 QML。能够从 QML 实例化对象，可以更好地控制 QML 中的对象生命周期。为了实现这一点，我们需要将 *类* 暴露给 QML，而不是 *对象*。

The class that is being exposed to QML is not affected by where it is instantiated. No change is needed to the class definition. However, instead of calling `setContextProperty`, the `qmlRegisterType` function is used. This function comes from the `PySide2.QtQml` module and takes five arguments:

要暴露给 QML 的类不受其实例化的影响。类定义不需要任何更改。然而，不是调用 `setContextProperty`，而是使用 `qmlRegisterType` 函数。这个函数来自 `PySide2.QtQml` 模块，需要五个参数：



* A reference to the class, `NumberGenerator` in the example below.（示例中的类引用，下面的 `NumberGenerator`）
* A module name, `'Generators'`.（模块名称，`'Generators'`）
* A module version consisting of a major and minor number, `1` and `0` meaning `1.0`.（模块版本，由主要和次要数字组成，`1` 和 `0` 表示 `1.0`）
* The QML name of the class, `'NumberGenerator'`（类的 QML 名称，`'NumberGenerator'`）

<<< @/docs/ch19-python/src/class-registered-type/class.py#global

In QML, we need to import the module, e.g. `Generators 1.0` and then instantiate the class as `NumberGenerator { ... }`. The instance now works like any other QML element.

在 QML 中，我们需要导入模块，例如 `Generators 1.0`，然后像任何其他 QML 元素一样实例化类，例如 `NumberGenerator { ... }`。实例现在像任何其他 QML 元素一样工作。

<<< @/docs/ch19-python/src/class-registered-type/main.qml#global

## A Model from Python（来自 Python 的模型）

One of the more interesting types of objects or classes to expose from Python to QML are item models. These are used with various views or the `Repeater` element to dynamically build a user interface from the model contents.

从 Python 暴露给 QML 的更有趣的对象或类是项目模型。这些与各种视图或 `Repeater` 元素一起使用，以从模型内容动态构建用户界面。



In this section we will take an existing python utility for monitoring CPU load (and more), `psutil`, and expose it to QML via a custom made item model called `CpuLoadModel`. You can see the program in action below:

在本节中，我们将使用一个现有的 Python 实用程序来监控 CPU 负载（以及其他），`psutil`，并通过一个名为 `CpuLoadModel` 的自定义项目模型将其暴露给 QML。您可以在下面看到程序的运行情况：

![](./assets/cpu-load-model.png)

::: tip
The psutil library can be found at [https://pypi.org/project/psutil/](https://pypi.org/project/psutil/) .

psutil 库可以在 [https://pypi.org/project/psutil/](https://pypi.org/project/psutil/) 找到。
:::

*“psutil (process and system utilities) is a cross-platform library for retrieving information on running processes and system utilization (CPU, memory, disks, network, sensors) in Python.”*

*“psutil (进程和系统实用程序) 是一个跨平台的 Python 库，用于检索有关正在运行的进程和系统利用情况（CPU、内存、磁盘、网络、传感器）的信息。”*



You can install psutil using `pip install psutil`.

您可以使用 `pip install psutil` 安装 psutil。


We will use the `psutil.cpu_percent` function ([documentation](https://psutil.readthedocs.io/en/latest/#psutil.cpu_percent)) to sample the CPU load per core every second. To drive the sampling we use a `QTimer`. All of this is exposed through the `CpuLoadModel` which is a `QAbstractListModel`.

我们将使用 `psutil.cpu_percent` 函数（[文档](https://psutil.readthedocs.io/en/latest/#psutil.cpu_percent)）每秒对每个核心的 CPU 负载进行采样。为了驱动采样，我们使用一个 `QTimer`。所有这些都通过 `CpuLoadModel` 暴露，它是一个 `QAbstractListModel`。


Item models are interesting. They allow you to represent a two dimensional data set, or even nested data sets, if using the `QAbstractItemModel`. The `QAbstractListModel` that we use allow us to represent a list of items, so a one dimensional set of data. It is possible to implement a nested set of lists, creating a tree, but we will only create one level.

项目模型很有趣。它们允许你表示二维数据集，或者使用 `QAbstractItemModel` 时，甚至可以表示嵌套的数据集。我们使用的 `QAbstractListModel` 允许我们表示一个项目列表，所以是一个一维的数据集。可以实现嵌套的列表集，创建一个树，但我们只会创建一个级别。

To implement a `QAbstractListModel`, it is necessary to implement the methods `rowCount` and `data`. The `rowCount` returns the number of CPU cores which we get using the `psutil.cpu_count` method. The `data` method returns data for different *roles*. We only support the `Qt.DisplayRole`, which corresponds to what you get when you refer to `display` inside the delegate item from QML.

要实现 `QAbstractListModel`，需要实现方法 `rowCount` 和 `data`。`rowCount` 返回我们使用 `psutil.cpu_count` 方法得到的 CPU 核心数量。`data` 方法返回不同 *角色* 的数据。我们只支持 `Qt.DisplayRole`，对应于您在 QML 中从委托项中引用 `display` 时得到的内容。

Looking at the code for the model, you can see that the actual data is stored in the `__cpu_load` list. If a valid request is made to `data`, i.e. the row, column and role is correct, we return the right element from the `__cpu_load` list. Otherwise we return `None` which corresponds to an uninitialized `QVariant` on the Qt side.

查看模型的代码，您可以看到实际的数据存储在 `__cpu_load` 列表中。如果对 `data` 的请求有效，即行、列和角色正确，我们从 `__cpu_load` 列表中返回正确的元素。否则我们返回 `None`，对应于 Qt 侧未初始化的 `QVariant`。



Every time the update timer (`__update_timer`) times out, the `__update` method is triggered. Here, the `__cpu_load` list is updated, but we also emit the `dataChanged` signal, indicating that all data was changed. We do not do a `modelReset` as that also implies that the number of items might have changed.


每次更新计时器（`__update_timer`）超时时，会触发 `__update` 方法。在这里，`__cpu_load` 列表被更新，但我们还发出了 `dataChanged` 信号，指示所有数据都已更改。我们不执行 `modelReset`，因为那还意味着项目数量可能已更改。


Finally, the `CpuLoadModel` is exposed to QML are a registered type in the `PsUtils` module.

最后，`CpuLoadModel` 被暴露给 QML，并在 `PsUtils` 模块中注册为一个类型。



<<< @/docs/ch19-python/src/model/model.py#global

On the QML side we use a `ListView` to show the CPU load. The model is bound to the `model` property. For each item in the model a `delegate` item will be instantiated. In this case that means a `Rectangle` with a green bar (another `Rectangle`) and a `Text` element displaying the current load.

在 QML 侧，我们使用一个 `ListView` 来显示 CPU 负载。模型绑定到 `model` 属性。对于模型中的每个项目，都会实例化一个 `delegate` 项目。在这种情况下，这意味着一个带有绿色条（另一个 `Rectangle`）和显示当前负载的 `Text` 元素的 `Rectangle`。

<<< @/docs/ch19-python/src/model/main.qml#global
